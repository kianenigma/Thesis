
@article{al-bassamChainspaceShardedSmart2017,
  title = {Chainspace: {{A Sharded Smart Contracts Platform}}},
  shorttitle = {Chainspace},
  author = {{Al-Bassam}, Mustafa and Sonnino, Alberto and Bano, Shehar and Hrycyszyn, Dave and Danezis, George},
  year = {2017},
  month = aug,
  abstract = {Chainspace is a decentralized infrastructure, known as a distributed ledger, that supports user defined smart contracts and executes user-supplied transactions on their objects. The correct execution of smart contract transactions is verifiable by all. The system is scalable, by sharding state and the execution of transactions, and using S-BAC, a distributed commit protocol, to guarantee consistency. Chainspace is secure against subsets of nodes trying to compromise its integrity or availability properties through Byzantine Fault Tolerance (BFT), and extremely highauditability, non-repudiation and `blockchain' techniques. Even when BFT fails, auditing mechanisms are in place to trace malicious participants. We present the design, rationale, and details of Chainspace; we argue through evaluating an implementation of the system about its scaling and other features; we illustrate a number of privacy-friendly smart contracts for smart metering, polling and banking and measure their performance.},
  archivePrefix = {arXiv},
  eprint = {1708.03778},
  eprinttype = {arxiv},
  file = {/Users/kianenigma/Documents/Zotero/storage/TVK8CMEK/Al-Bassam et al. - 2017 - Chainspace A Sharded Smart Contracts Platform.pdf},
  journal = {ArXiv170803778 Cs},
  keywords = {Computer Science - Cryptography and Security},
  language = {en},
  primaryClass = {cs}
}

@article{anjanaSTMEfficientConcurrent2019,
  title = {[{{STM}}] {{Efficient Concurrent Execution}} of {{Smart Contracts}} in {{Blockchains}} Using {{Object}}-Based {{Transactional Memory}}},
  author = {Anjana, Parwat Singh and Kumari, Sweta and Peri, Sathya and Somani, Archit},
  year = {2019},
  month = aug,
  abstract = {Several popular blockchains such as Ethereum executes complex transactions in blocks through user-defined scripts known as smart contracts. Normally, a block of the chain consists of multiple Smart Contract Transactions (SCTs) which are added by a miner. To append a correct block into the blockchain, miner executes these SCTs sequentially and store the final state in the block. The remaining peers on receiving this block act as validators. The validators again sequentially re-execute the SCTs of the block as a part of the consensus protocol. If the validators agree with the final state of the block as recorded by the miner, then the block is said to be validated and is added to the blockchain. In Ethereum and other blockchains that support cryptocurrencies, a miner gets an incentive every time such a valid block is successfully added to the blockchain.},
  archivePrefix = {arXiv},
  eprint = {1904.00358},
  eprinttype = {arxiv},
  file = {/Users/kianenigma/Documents/Zotero/storage/JEFDZEVL/Anjana et al. - 2019 - Efficient Concurrent Execution of Smart Contracts .pdf},
  journal = {ArXiv190400358 Cs},
  keywords = {Computer Science - Distributed; Parallel; and Cluster Computing},
  language = {en},
  primaryClass = {cs}
}

@article{anjanaSTMEfficientFramework2019,
  title = {[{{STM}}] {{An Efficient Framework}} for {{Optimistic Concurrent Execution}} of {{Smart Contracts}}},
  author = {Anjana, Parwat Singh and Kumari, Sweta and Peri, Sathya and Rathor, Sachin and Somani, Archit},
  year = {2019},
  month = jan,
  abstract = {Blockchain platforms such as Ethereum and several others execute complex transactions in blocks through userdefined scripts known as smart contracts. Normally, a block of the chain consists of multiple transactions of smart contracts which are added by a miner. To append a correct block into the blockchain, miners execute these transactions of smart contracts sequentially. Later the validators serially re-execute the smart contract transactions of the block. If the validators agree with the final state of the block as recorded by the miner, then the block is said to be validated. It is then added to the blockchain using a consensus protocol. In Ethereum and other blockchains that support cryptocurrencies, a miner gets an incentive every time such a valid block successfully added to the blockchain.},
  archivePrefix = {arXiv},
  eprint = {1809.01326},
  eprinttype = {arxiv},
  file = {/Users/kianenigma/Documents/Zotero/storage/8MX9L7LC/Anjana et al. - 2019 - An Efficient Framework for Optimistic Concurrent E.pdf},
  journal = {ArXiv180901326 Cs},
  keywords = {Computer Science - Distributed; Parallel; and Cluster Computing},
  language = {en},
  primaryClass = {cs}
}

@book{antonopoulosMasteringEthereumBuilding2019,
  title = {Mastering {{Ethereum}}: Building Smart Contracts and {{DApps}}},
  shorttitle = {Mastering {{Ethereum}}},
  author = {Antonopoulos, Andreas M. and Wood, Gavin},
  year = {2019},
  edition = {First edition},
  publisher = {{O'Reilly}},
  address = {{Sebastopol, CA}},
  abstract = {Ethereum represents the gateway to a worldwide, decentralized computing paradigm. This platform enables you to run decentralized applications (DApps) and smart contracts that have no central points of failure or control, integrate with a payment network, and operate on an open blockchain. With this practical guide, Andreas M. Antonopoulos and Gavin Wood provide everything you need to know about building smart contracts and DApps on Ethereum and other virtual-machine blockchains. Discover why IBM, Microsoft, NASDAQ, and hundreds of other organizations are experimenting with Ethereum. This essential guide shows you how to develop the skills necessary to be an innovator in this growing and exciting new industry},
  annotation = {OCLC: ocn967583559},
  isbn = {978-1-4919-7194-9},
  keywords = {Blockchain,Blockchains (Databases),Cloud Computing,Dezentralisation,Netzwerk,Programming,Vernetzung,Verteiltes System,Virtual computer systems,Web applications},
  lccn = {QA76.9.D32 A57 2019}
}

@article{banoConsensusAgeBlockchains2017,
  title = {Consensus in the {{Age}} of {{Blockchains}}},
  author = {Bano, Shehar and Sonnino, Alberto and {Al-Bassam}, Mustafa and Azouvi, Sarah and McCorry, Patrick and Meiklejohn, Sarah and Danezis, George},
  year = {2017},
  month = nov,
  abstract = {The blockchain initially gained traction in 2008 as the technology underlying bitcoin, but now has been employed in a diverse range of applications and created a global market worth over \$150B as of 2017. What distinguishes blockchains from traditional distributed databases is the ability to operate in a decentralized setting without relying on a trusted third party. As such their core technical component is consensus: how to reach agreement among a group of nodes. This has been extensively studied already in the distributed systems community for closed systems, but its application to open blockchains has revitalized the field and led to a plethora of new designs. The inherent complexity of consensus protocols and their rapid and dramatic evolution makes it hard to contextualize the design landscape. We address this challenge by conducting a systematic and comprehensive study of blockchain consensus protocols. After first discussing key themes in classical consensus protocols, we describe: first protocols based on proof-of-work (PoW), second proof-of-X (PoX) protocols that replace PoW with more energy-efficient alternatives, and third hybrid protocols that are compositions or variations of classical consensus protocols. We develop a framework to evaluate their performance, security and design properties, and use it to systematize key themes in the protocol categories described above. This evaluation leads us to identify research gaps and challenges for the community to consider in future research endeavours.},
  archivePrefix = {arXiv},
  eprint = {1711.03936},
  eprinttype = {arxiv},
  file = {/Users/kianenigma/Documents/Zotero/storage/NK7PUPVA/Bano et al_2017_Consensus in the Age of Blockchains.pdf;/Users/kianenigma/Documents/Zotero/storage/RGPBVV56/1711.html},
  journal = {ArXiv171103936 Cs},
  keywords = {Computer Science - Cryptography and Security},
  primaryClass = {cs}
}

@article{baranDistributedCommunicationsNetworks1964,
  title = {On {{Distributed Communications Networks}}},
  author = {Baran, P.},
  year = {1964},
  month = mar,
  volume = {12},
  pages = {1--9},
  issn = {1558-2647},
  doi = {10.1109/TCOM.1964.1088883},
  abstract = {This paper briefly reviews the distributed communication network concept in which each station is connected to all adjacent stations rather than to a few switching points, as in a centralized system. The payoff for a distributed configuration in terms of survivability in the cases of enemy attack directed against nodes, links or combinations of nodes and links is demonstrated. A comparison is made between diversity of assignment and perfect switching in distributed networks, and the feasibility of using low-cost unreliable communication links, even links so unreliable as to be unusable in present type networks, to form highly reliable networks is discussed. The requirements for a future all-digital data distributed network which provides common user service for a wide range of users having different requirements is considered. The use of a standard format message block permits building relatively simple switching mechanisms using an adaptive store-and-forward routing policy to handle all forms of digital data including digital voice. This network rapidly responds to changes in the network status. Recent history of measured network traffic is used to modify path selection. Simulation results are shown to indicate that highly efficient routing can be performed by local control without the necessity for any central, and therefore vulnerable, control point.},
  file = {/Users/kianenigma/Documents/Zotero/storage/92RRMTSY/Baran_1964_On Distributed Communications Networks.pdf;/Users/kianenigma/Documents/Zotero/storage/EUX5ZGEB/1088883.html},
  journal = {IEEE Trans. Commun. Syst.},
  keywords = {Buildings,Centralized control,Communication networks,Communication switching,Communication system control,History,Information systems,Network synthesis,Routing,Telecommunication network reliability},
  number = {1}
}

@article{bartolettiStaticTrueConcurrent2019,
  title = {[{{Static}}] {{A}} True Concurrent Model of Smart Contracts Executions},
  author = {Bartoletti, Massimo and Galletta, Letterio and Murgia, Maurizio},
  year = {2019},
  month = may,
  abstract = {One of the key features of modern blockchain platforms is the possibility of executing smart contracts, i.e. computer programs that transfer digital assets between users, according to pre-agreed rules. Crucially, the execution of smart contracts must be correct even in the presence of (a minority of) adversaries in the peer-to-peer network that maintains the blockchain. To enforce this property without a trusted authority, the nodes follow a consensus protocol, which determines which node can extend the blockchain at each moment. To this aim, nodes first collect a set of transactions from the network, representing the actions on the smart contracts required by users. Then, to compute the new state of the smart contracts, they put these transactions in sequence (in an arbitrary order), and execute them serially. Once this block of transactions is appended to the blockchain, the other nodes of the network validate it, by reexecuting the transactions in the same order. The serial execution of transactions does not take advantage of the multi-core architecture of modern processors, so contributing to limit the throughput of blockchains. In this paper we devise a static analysis technique for parallelizing the execution of transactions, in a formal setting based on Ethereum, the most widespread platform for smart contracts.},
  archivePrefix = {arXiv},
  eprint = {1905.04366},
  eprinttype = {arxiv},
  file = {/Users/kianenigma/Documents/Zotero/storage/T7DEFCTW/Bartoletti et al. - 2019 - A true concurrent model of smart contracts executi.pdf},
  journal = {ArXiv190504366 Cs},
  keywords = {Computer Science - Programming Languages,Statistical Analysis},
  language = {en},
  primaryClass = {cs}
}

@book{bashirMASTERINGBLOCKCHAINDistributed2018,
  title = {{{MASTERING BLOCKCHAIN}}: Distributed Ledger Technology, Decentralization, and Smart Contracts Explained, 2nd Edition;Distributed Ledger.},
  shorttitle = {{{MASTERING BLOCKCHAIN}}},
  author = {BASHIR, IMRAN},
  year = {2018},
  publisher = {{PACKT Publishing}},
  address = {{Place of publication not identified}},
  annotation = {OCLC: 1031340788},
  isbn = {978-1-78883-867-2},
  language = {English}
}

@inproceedings{bellareKeyingHashFunctions1996,
  title = {Keying {{Hash Functions}} for {{Message Authentication}}},
  booktitle = {Advances in {{Cryptology}} \textemdash{} {{CRYPTO}} '96},
  author = {Bellare, Mihir and Canetti, Ran and Krawczyk, Hugo},
  editor = {Koblitz, Neal},
  year = {1996},
  pages = {1--15},
  publisher = {{Springer}},
  address = {{Berlin, Heidelberg}},
  doi = {10.1007/3-540-68697-5_1},
  abstract = {The use of cryptographic hash functions like MD5 or SHA-1 for message authentication has become a standard approach in many applications, particularly Internet security protocols. Though very easy to implement, these mechanisms are usually based on ad hoc techniques that lack a sound security analysis.We present new, simple, and practical constructions of message authentication schemes based on a cryptographic hash function. Our schemes, NMAC and HMAC, are proven to be secure as long as the underlying hash function has some reasonable cryptographic strengths. Moreover we show, in a quantitative way, that the schemes retain almost all the security of the underlying hash function. The performance of our schemes is essentially that of the underlying hash function. Moreover they use the hash function (or its compression function) as a black box, so that widely available library code or hardware can be used to implement them in a simple way, and replaceability of the underlying hash function is easily supported.},
  file = {/Users/kianenigma/Documents/Zotero/storage/TKBCHIGZ/Bellare et al. - 1996 - Keying Hash Functions for Message Authentication.pdf},
  isbn = {978-3-540-68697-2},
  language = {en},
  series = {Lecture {{Notes}} in {{Computer Science}}}
}

@techreport{brumleyRemoteTimingAttacks2011,
  title = {Remote {{Timing Attacks}} Are {{Still Practical}}},
  author = {Brumley, Billy Bob and Tuveri, Nicola},
  year = {2011},
  abstract = {For over two decades, timing attacks have been an active area of research within applied cryptography. These attacks exploit cryptosystem or protocol implementations that do not run in constant time. When implementing an elliptic curve cryptosystem with a goal to provide side-channel resistance, the scalar multiplication routine is a critical component. In such instances, one attractive method often suggested in the literature is Montgomery's ladder that performs a fixed sequence of curve and field operations. This paper describes a timing attack vulnerability in OpenSSL's ladder implementation for curves over binary fields. We use this vulnerability to steal the private key of a TLS server where the server authenticates with ECDSA signatures. Using the timing of the exchanged messages, the messages themselves, and the signatures, we mount a lattice attack that recovers the private key. Finally, we describe and implement an effective countermeasure.},
  file = {/Users/kianenigma/Documents/Zotero/storage/2TFTRZXJ/Brumley and Tuveri - 2011 - Remote Timing Attacks are Still Practical.pdf;/Users/kianenigma/Documents/Zotero/storage/ZLE86VHF/232.html},
  keywords = {elliptic curve cryptography,lattice attacks.,public-key cryptography,side-channel attacks,timing attacks},
  number = {232}
}

@article{buterinCasperFriendlyFinality2019,
  title = {Casper the {{Friendly Finality Gadget}}},
  author = {Buterin, Vitalik and Griffith, Virgil},
  year = {2019},
  month = jan,
  abstract = {We introduce Casper, a proof of stake-based finality system which overlays an existing proof of work blockchain. Casper is a partial consensus mechanism combining proof of stake algorithm research and Byzantine fault tolerant consensus theory. We introduce our system, prove some desirable features, and show defenses against long range revisions and catastrophic crashes. The Casper overlay provides almost any proof of work chain with additional protections against block reversions.},
  archivePrefix = {arXiv},
  eprint = {1710.09437},
  eprinttype = {arxiv},
  file = {/Users/kianenigma/Documents/Zotero/storage/UJXGPEUU/Buterin_Griffith_2019_Casper the Friendly Finality Gadget.pdf;/Users/kianenigma/Documents/Zotero/storage/MRB8PIFI/1710.html},
  journal = {ArXiv171009437 Cs},
  keywords = {Computer Science - Cryptography and Security},
  primaryClass = {cs}
}

@inproceedings{carlucciHTTPUDPExperimental2015,
  title = {{{HTTP}} over {{UDP}}: An Experimental Investigation of {{QUIC}}},
  shorttitle = {{{HTTP}} over {{UDP}}},
  booktitle = {Proceedings of the 30th {{Annual ACM Symposium}} on {{Applied Computing}}},
  author = {Carlucci, Gaetano and De Cicco, Luca and Mascolo, Saverio},
  year = {2015},
  month = apr,
  pages = {609--614},
  publisher = {{Association for Computing Machinery}},
  address = {{Salamanca, Spain}},
  doi = {10.1145/2695664.2695706},
  abstract = {This paper investigates "Quick UDP Internet Connections" (QUIC), which was proposed by Google in 2012 as a reliable protocol on top of UDP in order to reduce Web Page retrieval time. We first check, through experiments, if QUIC can be safely deployed in the Internet and then we evaluate the Web page load time in comparison with SPDY and HTTP. We have found that QUIC reduces the overall page retrieval time with respect to HTTP in case of a channel without induced random losses and outperforms SPDY in the case of a lossy channel. The FEC module, when enabled, worsens the performance of QUIC.},
  file = {/Users/kianenigma/Documents/Zotero/storage/MW8556CI/Carlucci et al_2015_HTTP over UDP.pdf},
  isbn = {978-1-4503-3196-8},
  keywords = {congestion control,HTTP,QUIC,SPDY,TCP,UDP},
  series = {{{SAC}} '15}
}

@inproceedings{chaumUntraceableElectronicCash1990,
  title = {Untraceable {{Electronic Cash}}},
  booktitle = {Advances in {{Cryptology}} \textemdash{} {{CRYPTO}}' 88},
  author = {Chaum, David and Fiat, Amos and Naor, Moni},
  editor = {Goldwasser, Shafi},
  year = {1990},
  pages = {319--327},
  publisher = {{Springer}},
  address = {{New York, NY}},
  doi = {10.1007/0-387-34799-2_25},
  abstract = {The use of credit cards today is an act of faith on the p a t of all concerned. Each party is vulnerable to fraud by the others, and the cardholder in particular has no protection against surveillance.},
  file = {/Users/kianenigma/Documents/Zotero/storage/ENZHADK6/Chaum et al_1990_Untraceable Electronic Cash.pdf},
  isbn = {978-0-387-34799-8},
  keywords = {Account Number,Boolean Circuit,Digital Signature Scheme,Major Candidate,Proper Form},
  language = {en},
  series = {Lecture {{Notes}} in {{Computer Science}}}
}

@article{cheremInferringLocksAtomic2007,
  title = {Inferring {{Locks}} for {{Atomic Sections}}},
  author = {Cherem, Sigmund and Chilimbi, Trishul and Gulwani, Sumit},
  year = {2007},
  month = aug,
  abstract = {Atomic sections are a recent and popular idiom to support the development of concurrent programs. Updates performed within an atomic section should not be visible to other threads until the atomic section has been executed entirely. Traditionally, atomic sections are supported through the use of optimistic concurrency, either using a transactional memory hardware, or an \ldots},
  file = {/Users/kianenigma/Documents/Zotero/storage/8SNKUUPI/Cherem et al_2007_Inferring Locks for Atomic Sections.pdf;/Users/kianenigma/Documents/Zotero/storage/TNLG3RTQ/inferring-locks-for-atomic-sections.html},
  language = {en-US}
}

@misc{darrylRCast21Currency2019,
  title = {{{RCast}} 21: {{The Currency}} of {{Concurrency}}},
  shorttitle = {{{RCast}} 21},
  author = {{darryl}},
  year = {2019},
  month = mar,
  abstract = {In this RCast, Greg Meredith is joined by Isaac DeFrain and Christian Williams to discuss why concurrency is necessary in blockchain\textemdash and beyond.},
  file = {/Users/kianenigma/Documents/Zotero/storage/IMQFHZFH/rcast-21-the-currency-of-concurrency.html},
  journal = {RChain Blog},
  language = {en-US}
}

@inproceedings{deangelisPBFTVsProofofauthority2018,
  title = {{{PBFT}} vs Proof-of-Authority: Applying the {{CAP}} Theorem to Permissioned Blockchain},
  shorttitle = {{{PBFT}} vs Proof-of-Authority},
  booktitle = {Italian {{Conference}} on {{Cyber Security}} (06/02/18)},
  author = {De Angelis, Stefano and Aniello, Leonardo and Baldoni, Roberto and Lombardi, Federico and Margheri, Andrea and Sassone, Vladimiro},
  year = {2018},
  month = jan,
  abstract = {Permissioned blockchains are arising as a solution to federate companies prompting accountable interactions. A variety of consensus algorithms for such blockchains have been proposed, each of which has different benefits and drawbacks. Proof-of-Authority (PoA) is a new family of Byzantine fault-tolerant (BFT) consensus algorithms largely used in practice to ensure better performance than traditional Practical Byzantine Fault Tolerance (PBFT). However, the lack of adequate analysis of PoA hinders any cautious evaluation of their effectiveness in real-world permissioned blockchains deployed over the Internet, hence on an eventually synchronous network experimenting Byzantine nodes.{$<$}br/{$>$}In this paper, we analyse two of the main PoA algorithms, named Aura and Clique, both in terms of provided guarantees and performances. First, we derive their functioning including how messages are exchanged, then we weight, by relying on the CAP theorem, consistency, availability and partition tolerance guarantees. We also report a qualitative latency analysis based on message rounds. The analysis advocates that PoA for per- missioned blockchains, deployed over the Internet with Byzantine nodes, do not provide adequate consistency guarantees for scenarios where data integrity is essential. We claim that PBFT can fit better such scenarios, despite a limited loss in terms of performance.},
  collaborator = {De Angelis, Stefano and Aniello, Leonardo and Baldoni, Roberto and Lombardi, Federico and Margheri, Andrea and Sassone, Vladimiro},
  copyright = {accepted\_manuscript},
  file = {/Users/kianenigma/Documents/Zotero/storage/EMQUTS9L/415083.html},
  language = {en}
}

@inproceedings{demersEpidemicAlgorithmsReplicated1987,
  title = {Epidemic Algorithms for Replicated Database Maintenance},
  booktitle = {Proceedings of the Sixth Annual {{ACM Symposium}} on {{Principles}} of Distributed Computing},
  author = {Demers, Alan and Greene, Dan and Hauser, Carl and Irish, Wes and Larson, John and Shenker, Scott and Sturgis, Howard and Swinehart, Dan and Terry, Doug},
  year = {1987},
  month = dec,
  pages = {1--12},
  publisher = {{Association for Computing Machinery}},
  address = {{Vancouver, British Columbia, Canada}},
  doi = {10.1145/41840.41841},
  file = {/Users/kianenigma/Documents/Zotero/storage/264VBQIX/Demers et al_1987_Epidemic algorithms for replicated database maintenance.pdf},
  isbn = {978-0-89791-239-6},
  series = {{{PODC}} '87}
}

@book{diasEfficientCorrectTransactional,
  title = {Efficient and {{Correct Transactional Memory Programs Combining Snapshot Isolation}} and {{Static Analysis}}},
  author = {Dias, Ricardo J. and Louren{\c c}o, Jo{\~a}o M. and Pregui{\c c}a, Nuno M.},
  abstract = {The use of the Snapshot Isolation (SI) level in Transactional Memory (TM) eliminates the need of tracking memory read accesses, reducing the run-time overhead and fastening the commit phase. By detecting only write-write conflicts, SI allows many memory transactions to succeed that would otherwise abort if serialized. This higher commit rate comes at the expense of introducing anomalous behaviors by allowing some real conflicting transactions to commit. We aim at improving the performance of TM systems by running programs under SI, while guaranteeing a serializable semantics. This is achieved by static analysis of TM programs using Separation Logic to detect possible anomalies when running under SI. To guarantee correct behavior, the program code can be automatically modified to avoid these anomalies. Our approach can have an important impact on the performance of single multi-core node TM systems, and also of distributed TM systems by considerable reducing the required network traffic. 1},
  file = {/Users/kianenigma/Documents/Zotero/storage/HCGIJ423/Dias et al_Efficient and Correct Transactional Memory Programs Combining Snapshot.pdf;/Users/kianenigma/Documents/Zotero/storage/8KB3ZPQY/summary.html}
}

@article{dickersonSmartLocksAddingConcurrency2017,
  title = {[{{SmartLocks}}] {{Adding Concurrency}} to {{Smart Contracts}}},
  author = {Dickerson, Thomas and Gazzillo, Paul and Herlihy, Maurice and Koskinen, Eric},
  year = {2017},
  month = feb,
  abstract = {Modern cryptocurrency systems, such as Ethereum, permit complex financial transactions through scripts called smart contracts. These smart contracts are executed many, many times, always without real concurrency. First, all smart contracts are serially executed by miners before appending them to the blockchain. Later, those contracts are serially re-executed by validators to verify that the smart contracts were executed correctly by miners.},
  archivePrefix = {arXiv},
  eprint = {1702.04467},
  eprinttype = {arxiv},
  file = {/Users/kianenigma/Documents/Zotero/storage/EBS7L7ZZ/Dickerson et al. - 2017 - Adding Concurrency to Smart Contracts.pdf},
  journal = {ArXiv170204467 Cs},
  keywords = {Computer Science - Distributed; Parallel; and Cluster Computing},
  language = {en},
  primaryClass = {cs}
}

@article{diffieNewDirectionsCryptography1976,
  title = {New Directions in Cryptography},
  author = {Diffie, W. and Hellman, M.},
  year = {1976},
  month = nov,
  volume = {22},
  pages = {644--654},
  issn = {1557-9654},
  doi = {10.1109/TIT.1976.1055638},
  abstract = {Two kinds of contemporary developments in cryptography are examined. Widening applications of teleprocessing have given rise to a need for new types of cryptographic systems, which minimize the need for secure key distribution channels and supply the equivalent of a written signature. This paper suggests ways to solve these currently open problems. It also discusses how the theories of communication and computation are beginning to provide the tools to solve cryptographic problems of long standing.},
  file = {/Users/kianenigma/Documents/Zotero/storage/L5UG8GFP/Diffie_Hellman_1976_New directions in cryptography.pdf;/Users/kianenigma/Documents/Zotero/storage/VFX5M7D3/1055638.html},
  journal = {IEEE Trans. Inf. Theory},
  keywords = {Cryptography},
  number = {6}
}

@inproceedings{dodisVerifiableRandomFunction2005,
  title = {A {{Verifiable Random Function}} with {{Short Proofs}} and {{Keys}}},
  booktitle = {Public {{Key Cryptography}} - {{PKC}} 2005},
  author = {Dodis, Yevgeniy and Yampolskiy, Aleksandr},
  editor = {Vaudenay, Serge},
  year = {2005},
  pages = {416--431},
  publisher = {{Springer}},
  address = {{Berlin, Heidelberg}},
  doi = {10.1007/978-3-540-30580-4_28},
  abstract = {We give a simple and efficient construction of a verifiable random function (VRF) on bilinear groups. Our construction is direct. In contrast to prior VRF constructions [14,15], it avoids using an inefficient Goldreich-Levin transformation, thereby saving several factors in security. Our proofs of security are based on a decisional bilinear Diffie-Hellman inversion assumption, which seems reasonable given current state of knowledge. For small message spaces, our VRF's proofs and keys have constant size. By utilizing a collision-resistant hash function, our VRF can also be used with arbitrary message spaces. We show that our scheme can be instantiated with an elliptic group of very reasonable size. Furthermore, it can be made distributed and proactive.},
  file = {/Users/kianenigma/Documents/Zotero/storage/M2V9R3KL/Dodis_Yampolskiy_2005_A Verifiable Random Function with Short Proofs and Keys.pdf},
  isbn = {978-3-540-30580-4},
  keywords = {Input Size,Oracle Query,Random Function,Random Oracle,Security Parameter},
  language = {en},
  series = {Lecture {{Notes}} in {{Computer Science}}}
}

@inproceedings{dworkPricingProcessingCombatting1993,
  title = {Pricing via {{Processing}} or {{Combatting Junk Mail}}},
  booktitle = {Advances in {{Cryptology}} \textemdash{} {{CRYPTO}}' 92},
  author = {Dwork, Cynthia and Naor, Moni},
  editor = {Brickell, Ernest F.},
  year = {1993},
  pages = {139--147},
  publisher = {{Springer}},
  address = {{Berlin, Heidelberg}},
  doi = {10.1007/3-540-48071-4_10},
  abstract = {We present a computational technique for combatting junk mail in particular and controlling access to a shared resource in general. The main idea is to require a user to compute a moderately hard, but not intractable, function in order to gain access to the resource, thus preventing frivolous use. To this end we suggest several pricing functions, based on, respectively, extracting square roots modulo a prime, the Fiat-Shamir signature scheme, and the Ong-Schnorr-Shamir (cracked) signature scheme.},
  file = {/Users/kianenigma/Documents/Zotero/storage/HW43N7AT/Dwork_Naor_1993_Pricing via Processing or Combatting Junk Mail.pdf},
  isbn = {978-3-540-48071-6},
  keywords = {Difference Parameter,Hard Function,Hash Function,Price Function,Signature Scheme},
  language = {en},
  series = {Lecture {{Notes}} in {{Computer Science}}}
}

@misc{EffectsConcurrencyControl,
  title = {The {{Effects}} of {{Concurrency Control}} on {{Database Management System Performance}},},
  file = {/Users/kianenigma/Documents/Zotero/storage/4GNJEIA8/ADA103141.html},
  howpublished = {https://apps.dtic.mil/sti/citations/ADA103141}
}

@book{EnablingConcurrencySmart2018,
  title = {Enabling {{Concurrency}} on {{Smart Contracts Using Multiversion Ordering}}},
  year = {2018},
  publisher = {{Springer Berlin Heidelberg}},
  address = {{New York, NY}},
  file = {/Users/kianenigma/Documents/Zotero/storage/XHIUNM5D/2018 - Web and big data.pdf},
  isbn = {978-3-319-96892-6},
  language = {en}
}

@misc{EthereumWiki,
  title = {Ethereum/Wiki},
  abstract = {The Ethereum Wiki. Contribute to ethereum/wiki development by creating an account on GitHub.},
  file = {/Users/kianenigma/Documents/Zotero/storage/BP4YSNYE/White-Paper.html},
  howpublished = {https://github.com/ethereum/wiki},
  journal = {GitHub},
  language = {en}
}

@article{forestierBlockcliqueScalingBlockchains2019,
  title = {Blockclique: Scaling Blockchains through Transaction Sharding in a Multithreaded Block Graph},
  shorttitle = {Blockclique},
  author = {Forestier, S{\'e}bastien and Vodenicarevic, Damir and {Laversanne-Finot}, Adrien},
  year = {2019},
  month = sep,
  abstract = {Decentralized crypto-currencies based on the blockchain architecture are unable to scale to thousands of transactions per second. We define an architecture, called the blockclique, that addresses this limitation by sharding transactions in a block graph with multiple threads. A block in a given thread only contains transactions with input addresses assigned to this thread, and references one previous block of each thread as parents. When combined with a Proof-of-Stake node selection mechanism, the blockclique architecture reaches 10,000 transactions per second with a transaction time of less than a minute in our simulations, while being robust against known and projected attacks.},
  archivePrefix = {arXiv},
  eprint = {1803.09029},
  eprinttype = {arxiv},
  file = {/Users/kianenigma/Documents/Zotero/storage/GSYSGY8G/Forestier et al. - 2019 - Blockclique scaling blockchains through transacti.pdf},
  journal = {ArXiv180309029 Cs},
  keywords = {Computer Science - Cryptography and Security},
  language = {en},
  primaryClass = {cs}
}

@inproceedings{gervaisSecurityPerformanceProof2016,
  title = {On the {{Security}} and {{Performance}} of {{Proof}} of {{Work Blockchains}}},
  booktitle = {Proceedings of the 2016 {{ACM SIGSAC Conference}} on {{Computer}} and {{Communications Security}}},
  author = {Gervais, Arthur and Karame, Ghassan O. and W{\"u}st, Karl and Glykantzis, Vasileios and Ritzdorf, Hubert and Capkun, Srdjan},
  year = {2016},
  month = oct,
  pages = {3--16},
  publisher = {{Association for Computing Machinery}},
  address = {{Vienna, Austria}},
  doi = {10.1145/2976749.2978341},
  abstract = {Proof of Work (PoW) powered blockchains currently account for more than 90\% of the total market capitalization of existing digital cryptocurrencies. Although the security provisions of Bitcoin have been thoroughly analysed, the security guarantees of variant (forked) PoW blockchains (which were instantiated with different parameters) have not received much attention in the literature. This opens the question whether existing security analysis of Bitcoin's PoW applies to other implementations which have been instantiated with different consensus and/or network parameters. In this paper, we introduce a novel quantitative framework to analyse the security and performance implications of various consensus and network parameters of PoW blockchains. Based on our framework, we devise optimal adversarial strategies for double-spending and selfish mining while taking into account real world constraints such as network propagation, different block sizes, block generation intervals, information propagation mechanism, and the impact of eclipse attacks. Our framework therefore allows us to capture existing PoW-based deployments as well as PoW blockchain variants that are instantiated with different parameters, and to objectively compare the tradeoffs between their performance and security provisions.},
  file = {/Users/kianenigma/Documents/Zotero/storage/QJHAN3ZM/Gervais et al_2016_On the Security and Performance of Proof of Work Blockchains.pdf},
  isbn = {978-1-4503-4139-4},
  keywords = {bitcoin,blockchain,performance,security},
  series = {{{CCS}} '16}
}

@article{goldreichDefinitionsPropertiesZeroknowledge1994,
  title = {Definitions and Properties of Zero-Knowledge Proof Systems},
  author = {Goldreich, Oded and Oren, Yair},
  year = {1994},
  month = dec,
  volume = {7},
  pages = {1--32},
  issn = {0933-2790, 1432-1378},
  doi = {10.1007/BF00195207},
  journal = {J. Cryptology},
  language = {en},
  number = {1}
}

@article{guerraouiLockUnlockThat2019,
  title = {Lock\&\#x2013;{{Unlock}}: {{Is That All}}? {{A Pragmatic Analysis}} of {{Locking}} in {{Software Systems}}},
  shorttitle = {Lock\&\#x2013;{{Unlock}}},
  author = {Guerraoui, Rachid and Guiroux, Hugo and Lachaize, Renaud and Qu{\'e}ma, Vivien and Trigonakis, Vasileios},
  year = {2019},
  month = mar,
  volume = {36},
  pages = {1:1--1:149},
  issn = {0734-2071},
  doi = {10.1145/3301501},
  abstract = {A plethora of optimized mutex lock algorithms have been designed over the past 25 years to mitigate performance bottlenecks related to critical sections and locks. Unfortunately, there is currently no broad study of the behavior of these optimized lock algorithms on realistic applications that consider different performance metrics, such as energy efficiency and tail latency. In this article, we perform a thorough and practical analysis of synchronization, with the goal of providing software developers with enough information to design fast, scalable, and energy-efficient synchronization in their systems. First, we perform a performance study of 28 state-of-the-art mutex lock algorithms, on 40 applications, on four different multicore machines. We consider not only throughput (traditionally the main performance metric) but also energy efficiency and tail latency, which are becoming increasingly important. Second, we present an in-depth analysis in which we summarize our findings for all the studied applications. In particular, we describe nine different lock-related performance bottlenecks, and we propose six guidelines helping software developers with their choice of a lock algorithm according to the different lock properties and the application characteristics. From our detailed analysis, we make several observations regarding locking algorithms and application behaviors, several of which have not been previously discovered: (i) applications stress not only the lock\textendash unlock interface but also the full locking API (e.g., trylocks, condition variables); (ii) the memory footprint of a lock can directly affect the application performance; (iii) for many applications, the interaction between locks and scheduling is an important application performance factor; (vi) lock tail latencies may or may not affect application tail latency; (v) no single lock is systematically the best; (vi) choosing the best lock is difficult; and (vii) energy efficiency and throughput go hand in hand in the context of lock algorithms. These findings highlight that locking involves more considerations than the simple lock/unlock interface and call for further research on designing low-memory footprint adaptive locks that fully and efficiently support the full lock interface, and consider all performance metrics.},
  file = {/Users/kianenigma/Documents/Zotero/storage/4YC3FC3D/Guerraoui et al_2019_Lock&#x2013\;Unlock.pdf},
  journal = {ACM Trans. Comput. Syst.},
  keywords = {lock interface,locks,Multicore,performance bottleneck,synchronization},
  number = {1}
}

@article{haberHowTimestampDigital1991,
  title = {How to Time-Stamp a Digital Document},
  author = {Haber, Stuart and Stornetta, W. Scott},
  year = {1991},
  month = jan,
  volume = {3},
  pages = {99--111},
  issn = {1432-1378},
  doi = {10.1007/BF00196791},
  abstract = {The prospect of a world in which all text, audio, picture, and video documents are in digital form on easily modifiable media raises the issue of how to certify when a document was created or last changed. The problem is to time-stamp the data, not the medium. We propose computationally practical procedures for digital time-stamping of such documents so that it is infeasible for a user either to back-date or to forward-date his document, even with the collusion of a time-stamping service. Our procedures maintain complete privacy of the documents themselves, and require no record-keeping by the time-stamping service.},
  file = {/Users/kianenigma/Documents/Zotero/storage/II8CPFHQ/Haber_Stornetta_1991_How to time-stamp a digital document.pdf;/Users/kianenigma/Documents/Zotero/storage/QNNUR3SW/Haber_Stornetta_1991_How to time-stamp a digital document.pdf},
  journal = {J. Cryptology},
  language = {en},
  number = {2}
}

@inproceedings{hammondTransactionalMemoryCoherence2004,
  title = {Transactional {{Memory Coherence}} and {{Consistency}}},
  booktitle = {Proceedings of the 31st Annual International Symposium on {{Computer}} Architecture},
  author = {Hammond, Lance and Wong, Vicky and Chen, Mike and Carlstrom, Brian D. and Davis, John D. and Hertzberg, Ben and Prabhu, Manohar K. and Wijaya, Honggo and Kozyrakis, Christos and Olukotun, Kunle},
  year = {2004},
  month = mar,
  pages = {102},
  publisher = {{IEEE Computer Society}},
  address = {{USA}},
  abstract = {In this paper, we propos a new shared memory model: Transactionalmemory Coherence and Consistency (TCC).TCC providesa model in which atomic transactions are always the basicunit of parallel work, communication, memory coherence, andmemory reference consistency.TCC greatly simplifies parallelsoftware by eliminating the need for synchronization using conventionallocks and semaphores, along with their complexities.TCC hardware must combine all writes from each transaction regionin a program into a single packet and broadcast this packetto the permanent shared memory state atomically as a large block.This simplifies the coherence hardware because it reduces theneed for small, low-latency messages and completely eliminatesthe need for conventional snoopy cache coherence protocols, asmultiple speculatively written versions of a cache line may safelycoexist within the system.Meanwhile, automatic, hardware-controlledrollback of speculative transactions resolves any correctnessviolations that may occur when several processors attemptto read and write the same data simultaneously.The cost of thissimplified scheme is higher interprocessor bandwidth.To explore the costs and benefits of TCC, we study the characterisitcsof an optimal transaction-based memory system, and examinehow different design parameters could affect the performanceof real systems.Across a spectrum of applications, the TCC modelitself did not limit available parallelism.Most applications areeasily divided into transactions requiring only small write buffers,on the order of 4-8 KB.The broadcast requirements of TCCare high, but are well within the capabilities of CMPs and small-scaleSMPs with high-speed interconnects.},
  isbn = {978-0-7695-2143-5},
  series = {{{ISCA}} '04}
}

@inproceedings{heImprovedGossipAlgorithm2019,
  title = {An {{Improved Gossip Algorithm Based}} on {{Semi}}-{{Distributed Blockchain Network}}},
  booktitle = {2019 {{International Conference}} on {{Cyber}}-{{Enabled Distributed Computing}} and {{Knowledge Discovery}} ({{CyberC}})},
  author = {He, Xiaowei and Cui, Yiju and Jiang, Yunchao},
  year = {2019},
  month = oct,
  pages = {24--27},
  doi = {10.1109/CyberC.2019.00014},
  abstract = {With the continuous development of blockchain technology, more and more blockchain projects use semi-distributed P2P network structures. Although original gossip algorithm can be devoted to data synchronization in semi-distributed blockchain network, it can not be well applied to actual network environment. Since the probability of selecting a target node during data synchronization is fixed, it is inevitable that a message can be sent to a duplicate node. It will not only cause a lot of redundant messages, but also bring inefficient data synchronization. To address this problem, this paper proposes an improved HNA-Gossip algorithm which can reduce the probability of selecting duplicate nodes to send messages by recording historical node information dynamically. The simulation results show that, compared with the original gossip algorithm, various aspects of HNA-Gossip algorithm perform better.},
  file = {/Users/kianenigma/Documents/Zotero/storage/RUEQG7Q2/8946047.html},
  keywords = {blockchain technology,blockchain; HNA-Gossip algorithm; redundant message; data synchronization,cryptocurrencies,cryptography,data synchronization,duplicate node,historical node information,improved HNA-gossip algorithm,network environment,peer-to-peer computing,probability,redundant messages,semidistributed blockchain network,semidistributed P2P network structures,synchronisation}
}

@article{herlihyBlockchainsDistributedComputing2019,
  title = {Blockchains from a Distributed Computing Perspective},
  author = {Herlihy, Maurice},
  year = {2019},
  month = jan,
  volume = {62},
  pages = {78--85},
  issn = {0001-0782},
  doi = {10.1145/3209623},
  abstract = {The roots of blockchain technologies are deeply interwoven in distributed computing.},
  file = {/Users/kianenigma/Documents/Zotero/storage/E4G4QREV/Herlihy_2019_Blockchains from a distributed computing perspective.pdf},
  journal = {Commun. ACM},
  number = {2}
}

@article{herlihyTransactionalMemoryArchitectural1993,
  title = {Transactional Memory: Architectural Support for Lock-Free Data Structures},
  shorttitle = {Transactional Memory},
  author = {Herlihy, Maurice and Moss, J. Eliot B.},
  year = {1993},
  month = may,
  volume = {21},
  pages = {289--300},
  issn = {0163-5964},
  doi = {10.1145/173682.165164},
  abstract = {A shared data structure is lock-free if its operations do not require mutual exclusion. If one process is interrupted in the middle of an operation, other processes will not be prevented from operating on that object. In highly concurrent systems, lock-free data structures avoid common problems associated with conventional locking techniques, including priority inversion, convoying, and difficulty of avoiding deadlock. This paper introduces transactional memory, a new multiprocessor architecture intended to make lock-free synchronization as efficient (and easy to use) as conventional techniques based on mutual exclusion. Transactional memory allows programmers to define customized read-modify-write operations that apply to multiple, independently-chosen words of memory. It is implemented by straightforward extensions to any multiprocessor cache-coherence protocol. Simulation results show that transactional memory matches or outperforms the best known locking techniques for simple benchmarks, even in the absence of priority inversion, convoying, and deadlock.},
  journal = {SIGARCH Comput. Archit. News},
  number = {2}
}

@inproceedings{kedemControllingConcurrencyUsing1979,
  title = {Controlling Concurrency Using Locking Protocols},
  booktitle = {20th {{Annual Symposium}} on {{Foundations}} of {{Computer Science}} (Sfcs 1979)},
  author = {Kedem, Zvi and Silberschatz, Abraham},
  year = {1979},
  month = oct,
  pages = {274--285},
  issn = {0272-5428},
  doi = {10.1109/SFCS.1979.12},
  abstract = {This paper is concerned with the problem of developing locking protocols for ensuring the consistency of database systems that are accessed concurrently by a number of independent transactions. It is assumed that the database is modelled by a directed acyclic graph whose vertices correspond to the database entities, and whose arcs correspond to certain locking restrictions. Several locking protocols are presented. The weak protocol is shown to ensure consistency and deadlock-freedom only for databases that are organized as trees. For the databases that are organized as directed acyclic graphs, the strong protocol is presented. Discussion of SHARED and EXCLUSIVE locks is also included.},
  file = {/Users/kianenigma/Documents/Zotero/storage/WRPBJF8N/4568022.html},
  keywords = {Access protocols,Concurrency control,Concurrent computing,Control systems,Database systems,Programming profession,Resumes,System recovery,Transaction databases,Tree graphs}
}

@inproceedings{knightArchitectureMostlyFunctional1986,
  title = {An Architecture for Mostly Functional Languages},
  booktitle = {Proceedings of the 1986 {{ACM}} Conference on {{LISP}} and Functional Programming},
  author = {Knight, Tom},
  year = {1986},
  month = aug,
  pages = {105--112},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/319838.319854},
  isbn = {978-0-89791-200-6},
  series = {{{LFP}} '86}
}

@article{lamportByzantineGeneralsProblem1982,
  title = {The {{Byzantine Generals Problem}}},
  author = {Lamport, Leslie and Shostak, Robert and Pease, Marshall},
  year = {1982},
  month = jul,
  volume = {4},
  pages = {382--401},
  issn = {0164-0925},
  doi = {10.1145/357172.357176},
  file = {/Users/kianenigma/Documents/Zotero/storage/T4JM9RM8/Lamport et al_1982_The Byzantine Generals Problem.pdf},
  journal = {ACM Trans. Program. Lang. Syst.},
  number = {3}
}

@article{meneghettiSurveyEfficientParallelization2019,
  title = {A Survey on Efficient Parallelization of Blockchain-Based Smart Contracts},
  author = {Meneghetti, Alessio and Parise, Tommaso and Sala, Massimiliano and Taufer, Daniele},
  year = {2019},
  month = feb,
  abstract = {The main problem faced by smart contract platforms is the amount of time and computational power required to reach consensus. In a classical blockchain model, each operation is in fact performed by each node, both to update the status and to validate the results of the calculations performed by others. In this short survey we sketch some state-of-the-art approaches to obtain an efficient and scalable computation of smart contracts. Particular emphasis is given to sharding, a promising method that allows parallelization and therefore a more efficient management of the computational resources of the network.},
  archivePrefix = {arXiv},
  eprint = {1904.00731},
  eprinttype = {arxiv},
  file = {/Users/kianenigma/Documents/Zotero/storage/464EI3FB/Meneghetti et al. - 2019 - A survey on efficient parallelization of blockchai.pdf},
  journal = {ArXiv190400731 Cs},
  keywords = {Computer Science - Cryptography and Security},
  language = {en},
  primaryClass = {cs}
}

@inproceedings{merkleDigitalSignatureBased1988,
  title = {A {{Digital Signature Based}} on a {{Conventional Encryption Function}}},
  booktitle = {Advances in {{Cryptology}} \textemdash{} {{CRYPTO}} '87},
  author = {Merkle, Ralph C.},
  editor = {Pomerance, Carl},
  year = {1988},
  pages = {369--378},
  publisher = {{Springer}},
  address = {{Berlin, Heidelberg}},
  doi = {10.1007/3-540-48184-2_32},
  abstract = {A new digital signature based only on a conventional encryption function (such as DES) is described which is as secure as the underlying encryption function -- the security does not depend on the difficulty of factoring and the high computational costs of modular arithmetic are avoided. The signature system can sign an unlimited number of messages, and the signature size increases logarithmically as a function of the number of messages signed. Signature size in a `typical' system might range from a few hundred bytes to a few kilobytes, and generation of a signature might require a few hundred to a few thousand computations of the underlying conventional encryption function.},
  file = {/Users/kianenigma/Documents/Zotero/storage/MQXJ6C7R/Merkle_1988_A Digital Signature Based on a Conventional Encryption Function.pdf},
  isbn = {978-3-540-48184-3},
  keywords = {Count Field,Encryption Function,Infinite Tree,Modular Arithmetic,Signature Size},
  language = {en},
  series = {Lecture {{Notes}} in {{Computer Science}}}
}

@article{merkleSecureCommunicationsInsecure1978,
  title = {Secure Communications over Insecure Channels},
  author = {Merkle, Ralph C.},
  year = {1978},
  month = apr,
  volume = {21},
  pages = {294--299},
  issn = {0001-0782},
  doi = {10.1145/359460.359473},
  abstract = {According to traditional conceptions of cryptographic security, it is necessary to transmit a key, by secret means, before encrypted massages can be sent securely. This paper shows that it is possible to select a key over open communications channels in such a fashion that communications security can be maintained. A method is described which forces any enemy to expend an amount of work which increases as the square of the work required of the two communicants to select the key. The method provides a logically new kind of protection against the passive eavesdropper. It suggests that further research on this topic will be highly rewarding, both in a theoretical and a practical sense.},
  file = {/Users/kianenigma/Documents/Zotero/storage/9U79GC8U/Merkle_1978_Secure communications over insecure channels.pdf},
  journal = {Commun. ACM},
  keywords = {communications security,computer network security,cryptography,cryptology,key distribution,passive eavesdropping,public key cryptosystem,security,wiretap},
  number = {4}
}

@article{mIOTANextGenerationBlock2018,
  title = {{{IOTA}}-{{Next Generation Block}} Chain},
  author = {M, Divya and Biradar, Nagaveni B.},
  year = {2018},
  month = apr,
  volume = {7},
  pages = {23823--23826},
  issn = {2319-7242},
  copyright = {Copyright (c) 2018 International Journal of Engineering and Computer Science},
  file = {/Users/kianenigma/Documents/Zotero/storage/NC6FTFJD/M_Biradar_2018_IOTA-Next Generation Block chain.pdf;/Users/kianenigma/Documents/Zotero/storage/GMNZX7PU/4007.html},
  journal = {Int. J. Eng. Comput. Sci.},
  language = {en},
  number = {04}
}

@misc{monicaPaulBaranOrigins,
  title = {Paul {{Baran}} and the {{Origins}} of the {{Internet}}},
  author = {Monica, 1776 Main Street Santa and {California 90401-3208}},
  abstract = {RAND researcher Paul Baran developed a solution that has evolved into one of the major technological innovations of our time.},
  file = {/Users/kianenigma/Documents/Zotero/storage/CBXD6FIV/baran.html},
  howpublished = {https://www.rand.org/about/history/baran.html},
  language = {en}
}

@article{morrisPerformanceAnalysisLocking1985,
  title = {Performance Analysis of Locking and Optimistic Concurrency Control Algorithms},
  author = {Morris, R. J. T and Wong, W. S},
  year = {1985},
  month = may,
  volume = {5},
  pages = {105--118},
  issn = {0166-5316},
  doi = {10.1016/0166-5316(85)90043-4},
  abstract = {New analytic models are presented which predict the maximum throughput of locking and optimistic concurrency control algorithms for a centralized database system. By making several simplifying assumptions, these models can be easily solved. The analytic results are tested against simulation and are shown to have an accuracy considerably better than some previously reported methods. The models are used to carry out a comparison between locking and optimistic control under stated assumptions. It is found that locking schemes consistently have higher maximum throughput than optimistic schemes.},
  file = {/Users/kianenigma/Documents/Zotero/storage/C5CYFSUB/0166531685900434.html},
  journal = {Performance Evaluation},
  keywords = {Database Performance,Locking Concurrency Control,Optimistic Concurrency Control,Performance Analysis,Queueing Models},
  language = {en},
  number = {2}
}

@article{nakamotoBitcoinPeertoPeerElectronic,
  title = {Bitcoin: {{A Peer}}-to-{{Peer Electronic Cash System}}},
  author = {Nakamoto, Satoshi},
  pages = {9},
  abstract = {A purely peer-to-peer version of electronic cash would allow online payments to be sent directly from one party to another without going through a financial institution. Digital signatures provide part of the solution, but the main benefits are lost if a trusted third party is still required to prevent double-spending. We propose a solution to the double-spending problem using a peer-to-peer network. The network timestamps transactions by hashing them into an ongoing chain of hash-based proof-of-work, forming a record that cannot be changed without redoing the proof-of-work. The longest chain not only serves as proof of the sequence of events witnessed, but proof that it came from the largest pool of CPU power. As long as a majority of CPU power is controlled by nodes that are not cooperating to attack the network, they'll generate the longest chain and outpace attackers. The network itself requires minimal structure. Messages are broadcast on a best effort basis, and nodes can leave and rejoin the network at will, accepting the longest proof-of-work chain as proof of what happened while they were gone.},
  file = {/Users/kianenigma/Documents/Zotero/storage/5NQ645QU/Nakamoto - Bitcoin A Peer-to-Peer Electronic Cash System.pdf},
  language = {en}
}

@article{pangOCCConcurrencyProtocol2019,
  title = {[{{OCC}}] {{Concurrency Protocol Aiming}} at {{High Performance}} of {{Execution}} and {{Replay}} for {{Smart Contracts}}},
  author = {Pang, Shuaifeng and Qi, Xiaodong and Zhang, Zhao and Jin, Cheqing and Zhou, Aoying},
  year = {2019},
  month = may,
  abstract = {Although the emergence of the programmable smart contract makes blockchain systems easily embrace a wider range of industrial areas, how to execute smart contracts efficiently becomes a big challenge nowadays. Due to the existence of Byzantine nodes, the mechanism of executing smart contracts is quite different from that in database systems, so that existing successful concurrency control protocols in database systems cannot be employed directly. Moreover, even though smart contract execution follows a two-phase style, i.e, the miner node executes a batch of smart contracts in the first phase and the validators replay them in the second phase, existing parallel solutions only focus on the optimization in the first phase, but not including the second phase.},
  archivePrefix = {arXiv},
  eprint = {1905.07169},
  eprinttype = {arxiv},
  file = {/Users/kianenigma/Documents/Zotero/storage/HNDVEQIK/Pang et al. - 2019 - Concurrency Protocol Aiming at High Performance of.pdf},
  journal = {ArXiv190507169 Cs},
  keywords = {Computer Science - Databases,Computer Science - Distributed; Parallel; and Cluster Computing},
  language = {en},
  primaryClass = {cs}
}

@article{perezBrokenMetreAttacking2020,
  title = {Broken {{Metre}}: {{Attacking Resource Metering}} in {{EVM}}},
  shorttitle = {Broken {{Metre}}},
  author = {Perez, Daniel and Livshits, Benjamin},
  year = {2020},
  month = mar,
  abstract = {Blockchain systems, such as Ethereum, use an approach called "metering" to assign a cost to smart contract execution, an approach which is designed to incentivise miners to operate the network and protect it against DoS attacks. In the past, the imperfections of Ethereum metering allowed several DoS attacks which were countered through modification of the metering mechanism. This paper presents a new DoS attack on Ethereum which systematically exploits its metering mechanism. We first replay and analyse several months of transactions, during which we discover a number of discrepancies in the metering model, such as significant inconsistencies in the pricing of the instructions. We further demonstrate that there is very little correlation between the execution cost and the utilised resources, such as CPU and memory. Based on these observations, we present a new type of DoS attack we call Resource Exhaustion Attack, which uses these imperfections to generate low-throughput contracts. To do this, we design a genetic algorithm that generates contracts with a throughput on average 200 times slower than typical contracts. We then show that all major Ethereum client implementations are vulnerable and, if running on commodity hardware, would be unable to stay in sync with the network when under attack. We argue that such an attack could be financially attractive not only for Ethereum competitors and speculators, but also for Ethereum miners. Finally, we discuss short-term and potential long-term fixes against such attacks. Our attack has been responsibly disclosed to the Ethereum Foundation and awarded a bug bounty reward of 5,000 USD.},
  archivePrefix = {arXiv},
  eprint = {1909.07220},
  eprinttype = {arxiv},
  file = {/Users/kianenigma/Documents/Zotero/storage/22NZR47G/Perez_Livshits_2020_Broken Metre.pdf;/Users/kianenigma/Documents/Zotero/storage/928RJB82/1909.html},
  journal = {ArXiv190907220 Cs},
  keywords = {Computer Science - Cryptography and Security},
  primaryClass = {cs}
}

@inproceedings{pervezComparativeAnalysisDAGBased2018,
  title = {A {{Comparative Analysis}} of {{DAG}}-{{Based Blockchain Architectures}}},
  booktitle = {2018 12th {{International Conference}} on {{Open Source Systems}} and {{Technologies}} ({{ICOSST}})},
  author = {Pervez, Huma and Muneeb, Muhammad and Irfan, Muhammad Usama and Haq, Irfan Ul},
  year = {2018},
  month = dec,
  pages = {27--34},
  doi = {10.1109/ICOSST.2018.8632193},
  abstract = {Blockchain is a shared distributed ledger that promises tamper-proof secure transactions over the highly available and resilient network involving multiple participants. Directed Acyclic Graph (DAG) has revolutionized the blockchain technology. Owing to its optimized validation mechanism, high scalability, efficient provenance, support for IoT and multiparty involvement, DAG is rapidly over-shadowing traditional blockchain architecture. In this paper, we present a comparative analysis of most popular DAG based blockchain architectures including Nxt, IOTA, Orumesh, DagCoin,Byteball, Nano and XDAG. The comparison is based on the functional data structures for maintaining the ledger, consensus algorithms, transaction validation, ledger size, scalability and popularity. Extracting the best features various DAG based blockchains, we move on to outline the best of all worlds DAG-based blockchain architecture.},
  file = {/Users/kianenigma/Documents/Zotero/storage/MVY7IBXL/8632193.html},
  keywords = {Blockchain,Byteball,Computer architecture,consensus algorithms,cryptography,Cryptography,DAG-based blockchain architectures,DagCoin,data structures,Directed acyclic graph,Directed Acyclic Graph,directed graphs,distributed databases,Distributed databases,feature extraction,functional data structures,IOTA,ledger size,Nano,Nxt,optimized validation mechanism,Orumesh,Peer-to-peer computing,Scalability,shared distributed ledger,tamper-proof secure transactions,transaction processing,transaction validation,XDAG}
}

@article{pirrongWillBlockchainBe2019,
  title = {Will {{Blockchain Be}} a {{Big Deal}}? {{Reasons}} for {{Caution}}},
  shorttitle = {Will {{Blockchain Be}} a {{Big Deal}}?},
  author = {Pirrong, Craig},
  year = {2019},
  volume = {31},
  pages = {98--104},
  issn = {1745-6622},
  doi = {10.1111/jacf.12379},
  abstract = {The initial enthusiasm for implementing blockchain in financial markets has been dampened considerably by its collision with economic realities. Though the author warns against avoiding the Panglossian trap of viewing ours as the best of all possible worlds, he reminds us that trusted institutions have evolved and emerged in a competitive environment as a means of economizing on transaction costs. Such costs arise from the nature of transactions, including crucially the information environment in which they take place. Though new technologies such as blockchain have the potential to reduce some of these costs, they often do so without fundamentally changing the underlying economic conditions that give rise to them. And as a result, institutions such as banks and exchanges that technologists scoff at may well prove surprisingly competitive and durable in the face of technological challengers. The most successful implementation of blockchain\textemdash Bitcoin\textemdash solves a very basic transactional challenge peculiar to cryptocurrency: the double spend problem. But it does so in a very expensive way, and many other transactions pose far more complex challenges. The three cautionary tales provided by the author\textemdash the first involving securities and derivatives trading and clearing, the second commodity trading, and the third proposals to ``equitize'' assets\textemdash all demonstrate the need to confront ``Chesterton's Fence'' when evaluating the potential of blockchain in any particular application. In other words, to understand the value of a new technology for a given set of functions, one must understand the economic forces that have shaped the processes and institutions that currently perform those functions. When such forces are considered, it often becomes apparent that new technologies like blockchain will not prove superior to existing practices\textemdash and may even create adverse unintended consequences that offset and perhaps even eliminate its beneficial effects.},
  annotation = {\_eprint: https://onlinelibrary.wiley.com/doi/pdf/10.1111/jacf.12379},
  copyright = {Copyright \textcopyright{} 2019 Cantillon and Mann},
  file = {/Users/kianenigma/Documents/Zotero/storage/7DCZ7YV6/jacf.html},
  journal = {J. Appl. Corp. Finance},
  language = {en},
  number = {4}
}

@article{saraphYOLOEmpiricalStudy2019,
  title = {[{{YOLO}}] {{An Empirical Study}} of {{Speculative Concurrency}} in {{Ethereum Smart Contracts}}},
  author = {Saraph, Vikram and Herlihy, Maurice},
  year = {2019},
  month = jan,
  abstract = {We use historical data to estimate the potential benefit of speculative techniques for executing Ethereum smart contracts in parallel. We replay transaction traces of sampled blocks from the Ethereum blockchain over time, using a simple speculative execution engine. In this engine, miners attempt to execute all transactions in a block in parallel, rolling back those that cause data conflicts. Aborted transactions are then executed sequentially. Validators execute the same schedule as miners. We find that our speculative technique yields estimated speed-ups starting at about 8-fold in 2016, declining to about 2-fold at the end of 2017, where speed-up is measured using either gas costs or instruction counts. We also observe that a small set of contracts are responsible for many data conflicts resulting from speculative concurrent execution.},
  archivePrefix = {arXiv},
  eprint = {1901.01376},
  eprinttype = {arxiv},
  file = {/Users/kianenigma/Documents/Zotero/storage/W4JW62EV/Saraph and Herlihy - 2019 - An Empirical Study of Speculative Concurrency in E.pdf;/Users/kianenigma/Documents/Zotero/storage/RD687X93/1901.html},
  journal = {ArXiv190101376 Cs},
  keywords = {Computer Science - Distributed; Parallel; and Cluster Computing},
  primaryClass = {cs}
}

@misc{ShareMemoryCommunicating,
  title = {Share {{Memory By Communicating}} - {{The Go Blog}}},
  file = {/Users/kianenigma/Documents/Zotero/storage/EWHWN3CE/codelab-share.html},
  howpublished = {https://blog.golang.org/codelab-share}
}

@article{shreyDiPETransFrameworkDistributed2019,
  title = {{{DiPETrans}}: {{A Framework}} for {{Distributed Parallel Execution}} of {{Transactions}} of {{Blocks}} in {{Blockchain}}},
  shorttitle = {{{DiPETrans}}},
  author = {Shrey, Baheti and Singh, Anjana Parwat and Sathya, Peri and Yogesh, Simmhan},
  year = {2019},
  month = jun,
  abstract = {In most of the modern day blockchain, transactions are executed serially by both miners and validators; also, PoW is determined serially. The serial execution limits the system throughput and increases transaction acceptance latency, even unable to exploit the modern multi-core resources efficiently.},
  archivePrefix = {arXiv},
  eprint = {1906.11721},
  eprinttype = {arxiv},
  file = {/Users/kianenigma/Documents/Zotero/storage/2G4F5UTT/Shrey et al. - 2019 - DiPETrans A Framework for Distributed Parallel Ex.pdf},
  journal = {ArXiv190611721 Cs},
  keywords = {Computer Science - Distributed; Parallel; and Cluster Computing},
  language = {en},
  primaryClass = {cs}
}

@techreport{sompolinskySPECTREFastScalable2016,
  title = {{{SPECTRE}}: {{A Fast}} and {{Scalable Cryptocurrency Protocol}}},
  shorttitle = {{{SPECTRE}}},
  author = {Sompolinsky, Yonatan and Lewenberg, Yoad and Zohar, Aviv},
  year = {2016},
  abstract = {A growing body of research on Bitcoin and other permissionless cryptocurrencies that utilize Nakamoto's blockchain has shown that they do not easily scale to process a high throughput of transactions, or to quickly approve individual transactions; blocks must be kept small, and their creation rates must be kept low in order to allow nodes to reach consensus securely. As of today, Bitcoin processes a mere 3-7 transactions per second, and transaction confirmation takes at least several minutes. We present SPECTRE, a new protocol for the consensus core of cryptocurrencies that remains secure even under high throughput and fast confirmation times. At any throughput, SPECTRE is resilient to attackers with up to 50\textbackslash\% of the computational power (up until the limit defined by network congestion and bandwidth constraints). SPECTRE can operate at high block creation rates, which implies that its transactions confirm in mere seconds (limited mostly by the round-trip-time in the network). Key to SPECTRE's achievements is the fact that it satisfies weaker properties than classic consensus requires. In the conventional paradigm, the order between any two transactions must be decided and agreed upon by all non-corrupt nodes. In contrast, SPECTRE only satisfies this with respect to transactions performed by honest users. We observe that in the context of money, two conflicting payments that are published concurrently could only have been created by a dishonest user, hence we can afford to delay the acceptance of such transactions without harming the usability of the system. Our framework formalizes this weaker set of requirements for a cryptocurrency's distributed ledger. We then provide a formal proof that SPECTRE satisfies these requirements.},
  file = {/Users/kianenigma/Documents/Zotero/storage/HBTZT9TA/Sompolinsky et al_2016_SPECTRE.pdf;/Users/kianenigma/Documents/Zotero/storage/65CRZM9F/1159.html},
  keywords = {applications,Bitcoin,cryptocurrencies,distributed algorithms},
  number = {1159}
}

@inproceedings{stewartPosterGRANDPAFinality2019,
  title = {Poster: {{GRANDPA Finality Gadget}}},
  shorttitle = {Poster},
  booktitle = {Proceedings of the 2019 {{ACM SIGSAC Conference}} on {{Computer}} and {{Communications Security}}},
  author = {Stewart, Alistair},
  year = {2019},
  month = nov,
  pages = {2649--2651},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/3319535.3363278},
  abstract = {We present GRANDPA, a finality gadget, that is a protocol that can be used to provide provable finality for a blockchain. It works in addition to a block production mechanism and a chain selection rule, that on their own would only provide eventual consensus. The design of GRANDPA aims at separating these two protocols as cleanly as possible and obtain formal guarantees for the finality gadget. GRANDPA attempts to finalise the prefix of the chain that \$2/3\$ of voters agree on, whether that is one or thousands blocks. It has been implemented by Parity Technologies and deployed on large testnets for the Polkadot protocol. We also present properties GRANDPA achieves and review GRANDPA's advantages in flexibility over comparable protocols.},
  isbn = {978-1-4503-6747-9},
  series = {{{CCS}} '19}
}

@article{stollCarbonFootprintBitcoin2019,
  title = {The {{Carbon Footprint}} of {{Bitcoin}}},
  author = {Stoll, Christian and Klaa{\ss}en, Lena and Gallersd{\"o}rfer, Ulrich},
  year = {2019},
  month = jul,
  volume = {3},
  pages = {1647--1661},
  publisher = {{Elsevier}},
  issn = {2542-4785, 2542-4351},
  doi = {10.1016/j.joule.2019.05.012},
  file = {/Users/kianenigma/Documents/Zotero/storage/Y3JXI2LB/S2542-4351(19)30255-7.html},
  journal = {Joule},
  language = {English},
  number = {7}
}

@inproceedings{togashiConcurrencyGoJava2014,
  title = {Concurrency in {{Go}} and {{Java}}: {{Performance}} Analysis},
  shorttitle = {Concurrency in {{Go}} and {{Java}}},
  booktitle = {2014 4th {{IEEE International Conference}} on {{Information Science}} and {{Technology}}},
  author = {Togashi, Naohiro and Klyuev, Vitaly},
  year = {2014},
  month = apr,
  pages = {213--216},
  issn = {2164-4357},
  doi = {10.1109/ICIST.2014.6920368},
  abstract = {Go is a new programming language developed by Google. Although it is still young compared to other programming languages, it already has modern and powerful features inherited from existing programming languages, and some of these are similar to Java. Go is designed for quick time development. Concurrency is the one of the main its features. In this paper, we analyze the performance of Go, and compare it with Java from two aspects: compile time and concurrency. There are many studies about the performance analysis and comparison of programming languages, but only a few publications investigate Go. Some of Go performance evaluation are based on the experimental release of Go. To analyze concurrency features, we implement simple matrix multiplication programs in both Go and Java. Java implementation uses Java Thread, and Go implementation uses Gor-outine and Channel. From the experiment, Go derived better performance than Java in both compile time and concurrency. Moreover, Go code shows the ease of concurrent programming. Go is still young, but we are convinced that Go will become the mainstream.},
  file = {/Users/kianenigma/Documents/Zotero/storage/PGZV4BPC/6920368.html},
  keywords = {Benchmark testing,Channel,compile time,concurrency,Concurrency,concurrency control,concurrency features,Concurrent computing,Educational institutions,Evaluation,Go,Go code,Google,Goroutine,Java,Java thread,Message systems,Performance,performance analysis,program compilers,Programming,programming language}
}

@article{turnerPolymorphicPiCalculusTheory1996,
  title = {The {{Polymorphic Pi}}-{{Calculus}}: {{Theory}} and {{Implementation}}},
  shorttitle = {The {{Polymorphic Pi}}-{{Calculus}}},
  author = {Turner, David},
  year = {1996},
  month = jul,
  publisher = {{University of Edinburgh. College of Science and Engineering. School of Informatics.}},
  abstract = {We investigate whether the Pi-calculus is able to serve as a good foundation for the design and implementation of a strongly-typed concurrent programming language. The first half of the dissertation examines whether the Pi-calculus supports a simple type system which is flexible enough to provide a suitable foundation for the type system of a concurrent programming language. The second half of the dissertation considers how to implement the Pi-calculus efficiently, starting with an abstract machine for Pi-calculus and finally presenting a compilation of Pi-calculus to C.    We start the dissertation by presenting a simple, structural type system for Pi-calculus, and then, after proving the soundness of our type system, show how to infer principal types for Pi-terms. This simple type system can be extended to include useful type-theoretic constructions such as recursive types and higher-order polymorphism. Higher-order polymorphism is important, since it gives us the ability to implement abstract datatypes in a type-safe manner, thereby providing a greater degree of modularity for Pi-calculus programs.    The functional computational paradigm plays an important part in many programming languages. It is well-known that the Pi-calculus can encode functional computation. We go further and show that the type structure of lambda-terms is preserved by such encodings, in the sense that we can relate the type of a lambda-term to the type of its encoding in the Pi-calculus. This means that a Pi-calculus programming language can genuinely support typed functional programming as a special case.    An efficient implementation of Pi-calculus is necessary if we wish to consider Pi-calculus as an operational foundation for concurrent programming. We first give a simple abstract machine for Pi-calculus and prove it correct. We then show how this abstract machine inspires a simple, but efficient, compilation of Pi-calculus to C (which now forms the basis of the Pict programming language implementation).},
  annotation = {Accepted: 2004-03-03T11:58:32Z},
  file = {/Users/kianenigma/Documents/Zotero/storage/HC5FMEGA/Turner_1996_The Polymorphic Pi-Calculus.pdf;/Users/kianenigma/Documents/Zotero/storage/2BXGKNB7/395.html},
  language = {en}
}

@misc{vignaGreatDigitalCurrencyDebate2016,
  title = {The {{Great Digital}}-{{Currency Debate}}: `{{New}}' {{Ethereum Vs}}. {{Ethereum}} `{{Classic}}'},
  shorttitle = {The {{Great Digital}}-{{Currency Debate}}},
  author = {Vigna, Paul},
  year = {2016},
  month = aug,
  issn = {0099-9660},
  abstract = {The new digital currency Ethereum is only about three years old, but after a controversial software upgrade, it already has split in two.},
  chapter = {Markets},
  journal = {WSJ},
  keywords = {cryptocurrencies,Digital Currency,Ethereum,Hard Fork},
  language = {en-US}
}

@article{wangSurveyConsensusMechanisms2019,
  title = {A {{Survey}} on {{Consensus Mechanisms}} and {{Mining Strategy Management}} in {{Blockchain Networks}}},
  author = {Wang, Wenbo and Hoang, Dinh Thai and Hu, Peizhao and Xiong, Zehui and Niyato, Dusit and Wang, Ping and Wen, Yonggang and Kim, Dong In},
  year = {2019},
  volume = {7},
  pages = {22328--22370},
  issn = {2169-3536},
  doi = {10.1109/ACCESS.2019.2896108},
  abstract = {The past decade has witnessed the rapid evolution in blockchain technologies, which has attracted tremendous interests from both the research communities and industries. The blockchain network was originated from the Internet financial sector as a decentralized, immutable ledger system for transactional data ordering. Nowadays, it is envisioned as a powerful backbone/framework for decentralized data processing and data-driven self-organization in flat, open-access networks. In particular, the plausible characteristics of decentralization, immutability, and self-organization are primarily owing to the unique decentralized consensus mechanisms introduced by blockchain networks. This survey is motivated by the lack of a comprehensive literature review on the development of decentralized consensus mechanisms in blockchain networks. In this paper, we provide a systematic vision of the organization of blockchain networks. By emphasizing the unique characteristics of decentralized consensus in blockchain networks, our in-depth review of the state-of-the-art consensus protocols is focused on both the perspective of distributed consensus system design and the perspective of incentive mechanism design. From a game-theoretic point of view, we also provide a thorough review of the strategy adopted for self-organization by the individual nodes in the blockchain backbone networks. Consequently, we provide a comprehensive survey of the emerging applications of blockchain networks in a broad area of telecommunication. We highlight our special interest in how the consensus mechanisms impact these applications. Finally, we discuss several open issues in the protocol design for blockchain consensus and the related potential research directions.},
  file = {/Users/kianenigma/Documents/Zotero/storage/HGPBRFDE/Wang et al_2019_A Survey on Consensus Mechanisms and Mining Strategy Management in Blockchain.pdf;/Users/kianenigma/Documents/Zotero/storage/VNVR33KF/8629877.html},
  journal = {IEEE Access},
  keywords = {Bitcoin,block mining,Blockchain,blockchain backbone networks,blockchain consensus,blockchain technologies,Byzantine fault tolerance,consensus protocols,cryptocurrencies,cryptographic protocols,data mining,data-driven self-organization,decentralized consensus mechanisms,decentralized data processing,decentralized ledger system,distributed consensus system design,financial data processing,game theory,immutable ledger system,incentive mechanism design,incentive mechanisms,mining strategy management,open-access networks,Organizations,P2P networks,permissionless consensus,Protocols,Scalability,Standards organizations,transactional data ordering}
}

@article{weissOxideEssenceRust2020,
  title = {Oxide: {{The Essence}} of {{Rust}}},
  shorttitle = {Oxide},
  author = {Weiss, Aaron and Gierczak, Olek and Patterson, Daniel and Matsakis, Nicholas D. and Ahmed, Amal},
  year = {2020},
  month = aug,
  abstract = {Rust claims to advance industrial programming by bridging the gap between low-level systems programming and high-level application programming. At the heart of the argument that this enables programmers to build more reliable and efficient software is the borrow checker - a novel approach to ownership that aims to balance type system expressivity with usability. And yet, to date there is no core type system that captures Rust's notion of ownership and borrowing, and hence no foundation for research on Rust to build upon. In this work, we set out to capture the essence of this model of ownership by developing a type systems account of Rust's borrow checker. We present Oxide, a formalized programming language close to source-level Rust (but with fully-annotated types). This presentation takes a new view of lifetimes as an approximation of the provenances of references, and our type system is able to automatically compute this information through a substructural typing judgment. We provide the first syntactic proof of type safety for borrow checking using progress and preservation. Oxide is a simpler formulation of borrow checking - including recent features such as non-lexical lifetimes - that we hope researchers will be able to use as the basis for work on Rust.},
  archivePrefix = {arXiv},
  eprint = {1903.00982},
  eprinttype = {arxiv},
  file = {/Users/kianenigma/Documents/Zotero/storage/KGZCJ5L4/Weiss et al_2020_Oxide.pdf;/Users/kianenigma/Documents/Zotero/storage/M3H2XE9W/1903.html},
  journal = {ArXiv190300982 Cs},
  keywords = {Computer Science - Programming Languages},
  primaryClass = {cs}
}

@article{zhangAnalysisMainConsensus2019,
  title = {Analysis of the Main Consensus Protocols of Blockchain},
  author = {Zhang, Shijie and Lee, Jong-Hyouk},
  year = {2019},
  month = aug,
  issn = {2405-9595},
  doi = {10.1016/j.icte.2019.08.001},
  abstract = {Blockchain is the core technology of many cryptocurrencies. Blockchain as a distributed ledger technology has received extensive research attention. In addition to cryptography and P2P (peer-to-peer) technology, consensus protocols are also a fundamental part of the blockchain technology. A good consensus protocol can guarantee the fault tolerance and security of the blockchain systems. The consensus protocols currently used in most blockchain systems can be broadly divided into two categories: the probabilistic-finality consensus protocols and the absolute-finality consensus protocols. This paper introduces some of the main consensus protocols of these two categories, and analyzes their strengths and weaknesses as well as the applicable blockchain types.},
  file = {/Users/kianenigma/Documents/Zotero/storage/DVUFURQP/Zhang_Lee_2019_Analysis of the main consensus protocols of blockchain.pdf;/Users/kianenigma/Documents/Zotero/storage/AXTP79RC/S240595951930164X.html},
  journal = {ICT Express},
  keywords = {Blockchains,Consensus protocols,Cryptocurrencies},
  language = {en}
}


