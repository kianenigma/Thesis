\chapter{System Design} \label{chap:design}


\todo[inline]{

introductory paragraph explaining the outline of the chapter:

1. We will first talk about what different ways to speed up a blockchain as an prelude. Last item in
this list will be concurrency.

2. Then we will talk more about concurrency and different ways that it can be achieved, like a mini
\textit{related work} section, but I will not go into too much detail and spare that for later.

3. Based on this related work, I point out some deficiencies in them and come up with design
requirements.

4. Then finally I propose my design which addresses everything that I said is required.

}

\todo[inline]{At this point I should really define what is my metric. Thrhoughput? efficiency? what?


I am currently way more in favour of only using throughput (tx/sec).}

\section{Prelude: Speeding up a Blockchain - A Brief Overview}
\label{chap_design:sec:ways_to_speedup}

In this section, we briefly survey some of the ways through which the throughput of a blockchain can
be improved, and delineate which approach we focus on, for the rest of this work.

As mentioned, blockchains can be seen, in a very broad way, and from a transaction processing point
of view, as a \textit{decentralized state machine that transitions by means of transactions}. The
throughput of a blockchain network, measured in transactions per second, is a function of numerous
components and can be analysed from different points of view \footnote{and this categorization is by
no means exhaustive.}. While in this work we focus mainly on one aspect, it is helpful to enumerate
different viewpoints and see how each of them affect the overall performance.

\subsection{Consensus and Block Authoring}

As mentioned, the consensus protocol provides the means of ensuring that all nodes have a persistent
view of the state, and it can heavily contribute to the throughput of the system. Two common
consensus protocols are Proof of \textbf{Work} and Proof of \textbf{Stake}. They use the computation
power (\textit{work}) and a number of bonded tokens (\textit{stake}), respectively, as their
guarantees that an entity has \textit{authority} to perform some operation, such as authoring a
block. It is important to note that each of these consensus protocols has an \textit{inherently}
different performance \cite{survey_on_all}. Proof of work, as the names suggests, requires the
author to prove their legitimacy by providing a proof that they have solved a particular hashing
puzzle. This is slow by nature, and wastes a lot of computation power on each node that wants to
produce blocks, which in turn has a negative impact on the transaction throughput. Speeding-up this
metric requires the network to agree on an easier puzzle, that can in turn make the system less
secure \cite{security_of_bitcoin}. More precisely, the difficulty of the puzzle dictates the average
time any node needs to spend to be able to produce a block, which dictates the final throughput.

To the contrary, Proof of Stake does not need this this puzzle solving, which is beneficial in terms
of computation resources. Moreover, since the chance of any node being the author is determined by
their stake. In a such a authoring process, a smaller block-time is not insecure by itself. Even
more recent, we are seeing blockchains turning into verifiable random functions
\cite{Dodis_Yampolskiy_2005_VRF}\footnote{VRF for short.} for block authoring, and deploy a
traditional byzantine fault tolerance voting scheme on top of it to ensure finality. This further
decouples block production and finality, allowing production to proceed faster and and with even
less drag from the rest of the consensus.

All in all, one general approach towards increasing the throughput of a blockchain is to
\textit{re-think the consensus and block authoring mechanisms} that dictate when blocks are added to
the chain, and by whom, with what frequency. It is crucially important to note that any approach in
this domain falls somewhere in the spectrum of centralized-decentralized, where most often
approaches that are more centralized will be more capable of delivering better throughput, yet they
may not have some of the security and immutability guarantees of a blockchain. An example of this is
provided in table \ref{table:blockchain_types} and private blockchain.

\subsubsection{Sharding}

An interesting consensus-related optimisation that is gaining a lot of relevance in the recent year
is a technique, obtained from the databases field, called \textit{sharding}. Shards are slices of
data (in the database jargon) that are maintained on different nodes. In a blockchain system, shards
refer to sub-chains are are maintained by sub-networks of the whole system. In essence, instead of
keeping all the nodes in the entire system synchronized at all times, \textit{sharded blockchains}
consist of multiple smaller networks, each maintaining their own cannon chain. Albeit, most of the
time these chains all have the same prefix and only differ in the most recent blocks. At fixed
intervals, sub-networks come to agreement and synchronize their shards with one another. In some
sense, sharding allows smaller sub-networks to progress faster. Much work has been done in this
field \cite{Forestier_Vodenicarevic_Laversanne_Finot_2019_block_qlique,
Al_Bassam_Sonnino_Bano_Hrycyszyn_Danezis_2017_chainspace,
Shrey_Singh_Sathya_Yogesh_2019_diep_trans}.

\subsection{Chain Topology}

Another approach is changing the nature of the chain itself. A classic blockchain is theoretically
limited due to the fact that only one entity can append a block to the chain at each time. This
property will bring extra security, and make the chain state easier to reason about (i.e. there is
only one cannon chain). A radical approach is to question this property and allow different blocks
to be created at the same time. Consequently, this approach turns a blockchain from a literal
\textit{chain of blocks} into a \textit{graph}. Most often, such technologies are referred to
Directed Acyclic Graphs, \textbf{DAG} in short, solutions.

Altering chain topology will bring even more radical changes to the original idea of blockchain.
While being very promising for some fields, such as \textit{Internet of Things} and micro payments, we
will not consider DAGs in this work: we choose to adhere to the definitions provided in the previous
sections as our baseline of \textit{what a blockchain is}.

\subsection{Deploying Concurrency over Transaction Processing}

Finally, we can focus on the transaction processing view of the blockchain, and try and deploy
concurrency on top of it, leaving the other aspects such as consensus unchanged and, more
importantly, generic. This is very important, as it allows our approach to be deployed on many
chains, since it is independent of many consensus and network details. We have already explained how
a block author proposes a new block, and how all validators must re-execute the transactions to
ensure validity in the previous chapters. Thus, a block's lifecycle can be enumerated into two
different phases:

\begin{itemize}
	\item Block authoring: done by one block author.
	\item Block validation: done by all the nodes in the network.
\end{itemize}

By default, these phases must happen in a \textbf{sequential} manner, to ensure \textit{consistency}. In
other words, to ensure that the validators will come to the same state root as the one proposed by
the block author.

Our work specifically focuses on this aspect of of the blockchain systems and proposes a novel
approach to achieve concurrency within each block's execution, both in the authoring phase and in
the validation phase, thereby increasing the throughput.

\subsection{Analysis of the approaches and their merits} \label{chap_bg:subsec:summary_speedup}

Indeed, it is questionable how much gain will concurrency bring to the overall
throughput. To counter this doubt, we argue that the aim of this work is to foremost improve the
\textit{efficiency} of the transaction processing power of the blockchain. It is true that in a
specific chain, the network or consensus might be the main bottleneck of the throughput, and
concurrency cannot improve that by much. For example, most performance gains within concurrency
might be within milliseconds, while the block authoring delay is tens of seconds in some chain.
Nonetheless, most modern hardware have built-in features to run code in parallel,
which translates to adopting more concurrency on the application layer.

Therefore, we argue that our method is \textit{universal}, and independent of the underlying chain
specifications, as long as it adheres to our basic definitions in chapter \ref{chap:background},
such as having a state root, and authors and validators per block. And, despite its degree of
impact, concurrency can be applied to any chain. For some chains, it might be a dominant factor and
drastically improve the \textit{throughput}, whilst in others it might only contribute to the
\textit{efficiency} of the system and allow the blockchain to better use the hardware that is
provided to it\footnote{It is worth noting that having optimal hardware utilization (to reduce
costs) is an important factor in the blockchain industry, as many chains are ran by people who are
making profit out of running validators and miners.}.


\section{Concurrency Within Block Production and Validation}

This is where I will talk more about different approaches done by others within th realm of
concurrency. I will argue that there are two main appraoches, runtime and static and how each one
totally misses the benefits of the other one.

This section will answer research question 1.

We finish this section by setting a few design requirements:

1. The system should still be deterministic. i.e. anything done by authors will have the same impact
on validators. This is the single most important requirement.

2. The system should always terminate (no deadlock), and have as little contention as possible.

3. The system should not incur too much overhead on validators (i.e. I don't like dependency
graphs.)

\section{System Design} \label{chap_desgin:sec:design}

Basically https://www.notion.so/Architecture-V1-cfe987d4dd4345569b07649dcf00a85c

This section will answer research question 2.
